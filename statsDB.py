import numpy as np
import imageDB
#from skimage.measure import structural_similarity as ssim
from skimage.measure import compare_ssim as ssim
from scipy import ndimage
from scipy import signal
import os
#from pyemd import emd



def getCorrCoef(im, temp):
    
    #get pearson correllation coefficient (r^2) between two images (im and temp)
    im = imageDB.hist_match(im, temp)
    imM = np.ma.masked_array(im, mask=np.where(im == 0, 1, 0))
    r = np.ma.corrcoef(imM.compressed(), temp[~imM.mask])
    return r[0][1]

def getCorrCoefA(im, temp):
    #no mask is applied
    #get pearson correllation coefficient (r^2) between two images (im and temp)
    #import pdb; pdb.set_trace()
    #im = imageDB.hist_match(im, temp)
    #imM = np.ma.masked_array(im, mask=np.where(im >= 0, 0, 0))
    #r = np.ma.corrcoef(imM.compressed(), temp[~imM.mask])
    try:
        r=np.ma.corrcoef(im.ravel(), temp.ravel())
    except:
        #r = [['NaN', 'NaN'], ['NaN', 'NaN']]
        r = [[1, 1], [1, 1]]
        
    return r[0][1]

def testStat(im, temp):
    t=2
    return t
    
def structuralSimilarityIndex(im, temp):
    #no 3d function exists so takes the mean from each slice
    ssim1 = []
    for slice in range(0, im.shape[2]):
        ssim1.append(ssim(im[:,:, slice], temp[:,:, slice], dynamic_range = im.max() - im.min()))
    return np.mean(ssim1)

def meanSquaredError(img1, img2):
    
    return np.linalg.norm(img1.astype('double') - img2.astype('double'))
    
def earthMoversDistance(img1,img2):
    #could not implement because I could not find an image example or example that explained how to implement
    hist1 = ndimage.measurements.histogram(img1, 0, 1, 50)
    hist2 = ndimage.measurements.histogram(img2, 0, 1, 50)
    distance_matrix = np.array(np.ones(len(hist1)), np.ones(len(hist2)))
    return emd(img1, img2, distance_matrix)

def applyStats(img1, img2, stats):
    
    #load two images and then compare images with the indicated stats
    #img1 = 'path to file'
    #img2 = 'path to file'
    #stats = ['stat1' ...]
    #return img1, img2, stats
    #load image as arrays
    #print(img1)
    #print img1[0]
    if isinstance(img1[0], str):
        if os.path.isfile(img1[0]):
            img1 = imageDB.loadImgArray(img1[0])
        else:
            img1 = []
    else:
        img1 = img1[0]
    if isinstance(img2[0], str):
        if os.path.isfile(img2[0]):
            img2 = imageDB.loadImgArray(img2[0])
        else:
            img2 = []
        
    else:
        img2 = img2[0]
   
    #generate statistics
   
    '''
    #img1 = 1
    #img2 = 2
    img1 = img1[0]
    img2 = img2[0]
    '''
    s=[]
    #import pdb; pdb.set_trace()
    if len(img1) !=0  and len(img2) !=0 :
        for cstat in stats:
            #s.append(eval('statsDB.'+ cstat)(img1, img2))
            s.append(eval(cstat)(img1.astype(img2.dtype), img2))      
    else:
        for cstat in stats:
            #s.append(eval('statsDB.'+ cstat)(img1, img2))
            s.append(np.nan)      
    return s
    
def JacobianStats(inputImage, range1):
    #input a jacobian image generated by ANTSJacobian and output histogram
    #need to include values above maximum in range1
    inputImage = imageDB.loadNifti(inputImage)
    range1 = np.append(range1, np.max(inputImage))
    counts, range1 = np.hist(inputImage, range1)
    return counts

class getImgStats(object):
    def __init__(self, inputfile):
        self.ar1 = imageDB.loadImgArray2(inputfile)
    
    def max(self):
        return np.max(self.ar1)
    
    def min(self):
        return np.min(self.ar1)
    
    def mean(self):
        return np.mean(self.ar1)
    
    def median(self):
        return np.median(self.ar1)
    
    def hist(self, range1):
        return np.histogram(self.ar1, range1, density=False)
    
    def returnStats(self, stats):
        out1 = []
        for cstat in stats:
            out1.append(eval('self.' +cstat + '()'))
        return out1
   
   
def getPeriodgram(arr1, fs):
    freq, ps = signal.periodogram(arr1, fs)
    return ps
